# Ripple Documentation

Ripple is a distributed state management pipeline that uses NATS Core pub/sub, NATS JetStream for persistence, and a lightweight node.js instance for an in-memory state store. 

Here is a diagram of the services that make up the Ripple pipeline:

{% image src="https://storage.googleapis.com/markdoc-snippet-imgs/uploaded/demouser%40devcenter/9bb67701-9f86-41e4-93c4-56eec0e03f87" /%}

We can think of a client as being a person’s home, their websocket their mailbox. When a user sends a piece of mail to the postoffice, they would like every person on their mailing list to receive the same message. The original message is copied x number of times and sent to everyone listening. Its the mailmen/women, mail trucks, distribution centers that make up the Ripple pipeline. 

## Ripple Components
### State (client & server)
The shape of your state will depend on your app and business logic. If you a creating a video conferencing app, you may have state that tracks users, raised hands, emojis, breakout room data, and much more. 

### Events (client & server)
Events are what will cause your state to change over time. A new user joins a room, someone raises their hand, another user leaves, and a breakout session is over. All of these events will mutate the state tree in one way or another.

### WebSocket Payloads & Validation (client & server)
The Ripple pipeline uses websockets to send and receive payloads triggered by events. When user A raises their hand, users B, C, and D must receive the payload generated by that event. That payload can take on any shape. It’s good practice to validate those payloads.

### Event Handlers (server)
If your app has an event, it needs a handler to act on that event. Event handlers run on the server side and will mutate the state tree according to the action being performed. If user A raises their hand, the raise-hand event handler will find that userId in the user object, and set the user object’s handRaised property to true. 

### Read/Modify/Write Handlers (server)
Read/Modify/Write handlers are a special type of event handler that run on the service that has the source of truth in-memory. Within a RMW handler, you have access to live state. These are needed when an event needs access to the current state to perform an action on it. For example, if your app has a simple count event that increments a counter by 1, you need access to the current count variable before you can increment that count by 1, your operation would look something like count = count + 1.

### Event Reducers (client)
Similar to other client state libraries, Ripple uses event reducers on the client side to mutate client side state. This state is not the same as the distributed server-side state. 

## Ripple Implementation
### WebSocket Connections
Ripple uses a WebSocket for bi-directional messaging that persists for the lifetime of a call. Before connecting to the `ripple-api` service, a room must first be created.

WebSocket Lifetime
1. Create a room
1. Send WebSocket request to endpoint
1. WebSocket messages are received and sent over persistent WebSocket
1. When the call is over, WebSocket will be disconnected

WebSocket connection URL follows the following pattern: `{{host}}/apps/ripple-api/ws/{{version}}?roomId={{roomId}}`
Where
- `version` is `v1`
- `roomId` is the room ID for an existing room

Example: `wss://mark.devspace.lsea4.livelyvideo.tv/apps/ripple-api/ws/v1?roomId=511AFACF407F46B9A7EB3C877346C763`

The first message sent on the websocket must be a `join` event. A `join` event is unique because it contains a JWT in the payload that will be used to authenticate and authorize the user, if required. 

An example `join` outgoing websocket message is:

```json
{
	"event": "join",
	"roomId": "{{globalRoomId}}",
	"payload": {
		"displayName": "Mark",
		"userId": "1",
        "jwt": {"userId": "1","roles": ["owner"]}
	}
}
```

All websocket messages require an `event`, `roomId`, and `payload`.

### Validators
Validators are recommended to validate websocket payloads. 

## Ripple Concepts

### Lifetime of State Tree
There are two types of state in Ripple - state that persists from one call to another, and ephemeral state that only lives on for the lifetime of a call. Examples of persistent state include the name of a room, the owner of the room, and any default room properties. Examples of ephemeral state include the users in a call, a user's raise hand flag, and breakout room information. Once the call is over, ephemeral state is reset to defaults, and persistent state is updated accordingly. 